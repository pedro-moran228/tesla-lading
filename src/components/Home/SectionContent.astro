---
import LayoutHeader from "../LayoutHeader.astro";

interface Props {
  homeSectionName: string;
  headerColor?: string;
  image?: { srcMobile: string; srcDesktop: string; alt: string };
  video?: { src: string };
}

const {
  homeSectionName,
  image,
  video,
  headerColor = "transparent",
} = Astro.props;
---

<section
  data-section-name={`section-${homeSectionName}`}
  data-header-color={headerColor}
  class="relative snap-center"
>
  <LayoutHeader />
  {
    video && (
      <div class="w-full h-full z-10 relative">
        <video
          class="w-full h-full object-cover object-center"
          src={video.src}
          autoplay
          muted
          loop
        />
      </div>
    )
  }

  {
    image && (
      <div class="bg-white w-full h-full z-10">
        <picture>
          <source
            srcset={image.srcMobile}
            media="(max-width: 639px)"
          />
          <source
            srcset={image.srcDesktop}
            media="(min-width: 640px)"
          />
          <source
            srcset={image.srcMobile}
            media="(min-width: 640px) and (orientation:portrait)"
          />
          <img
            class="h-full w-full object-top xs:object-[0px_35%] sm:object-center object-cover"
            src={image.srcDesktop}
            srcset={image.srcDesktop}
            alt="Home outfitted with Tesla Solar Roof"
          />
        </picture>
      </div>
    )
  }

  <section
    data-section-content={`section-${homeSectionName}-content`}
    class="fixed top-0 z-20 h-full w-full pb-[50px] sm:pb-[80px] opacity-0 flex flex-col justify-between text-center"
  >
    <slot />
  </section>
</section>

<script>
  const options = {
    root: null,
    rootMargin: "0px",
    threshold: 0.6,
  };

  const $sections = document.querySelectorAll(
    "[data-section-name]"
  ) as NodeListOf<HTMLElement>;

  const $sectionsContent = document.querySelectorAll(
    "[data-section-content]"
  ) as NodeListOf<HTMLElement>;

  const $homePage = document.querySelector("#home-page");
  const $header = document.querySelector("#leading-header") as HTMLElement;
  
  [...$sections].forEach(s => {
    s.style.height = `${window.innerHeight}px`;
  })

  function getVisiblePercentage(element) {
    const rect = element.getBoundingClientRect();
    const windowHeight =
      window.innerHeight || document.documentElement.clientHeight;

    const totalHeight = rect.bottom - rect.top;

    const outsideViewportHeight =
      Math.max(0, rect.top < 0 ? Math.abs(rect.top) : 0) +
      Math.max(
        0,
        rect.bottom - windowHeight > 0 ? rect.bottom - windowHeight : 0
      );

    const insideViewportHeight = totalHeight - outsideViewportHeight;

    const visiblePercentage = (insideViewportHeight / totalHeight) * 100;

    return visiblePercentage;
  }

  const calcScrollOpacity = (n) => (n - 60) / 25; // (increments the velocity of the opacity change)

  const createScrollHandler = ($section, $sectionContent, headerColor) => {
    return () => {
      const topDistance = $section.getBoundingClientRect().top;

      // verify if scroll is working fine for each section
      // console.log($section.attributes.getNamedItem("data-section-name").value);

      const $prevSection =
        ($section.previousElementSibling as HTMLElement) || null;
      const prevHeaderColor =
        $prevSection?.attributes.getNamedItem("data-header-color").value ??
        headerColor;

      if (topDistance <= 30) {
        $header.style.color = headerColor;
      } else {
        $header.style.color = prevHeaderColor;
      }

      const visiblePercentage = Math.round(getVisiblePercentage($section));
      $sectionContent.style.opacity = calcScrollOpacity(visiblePercentage);
    };
  };

  const scrollHandlers = {};

  let observer = new IntersectionObserver((entries) => {
    entries.forEach(({ target: $section, isIntersecting }) => {
      const sectionName =
        $section.attributes.getNamedItem("data-section-name").value;

      const $sectionContent = [...$sectionsContent].find((el) => {
        return (
          el.attributes.getNamedItem("data-section-content").value ===
          `${sectionName}-content`
        );
      }) as HTMLElement;

      const headerColor =
        $section.attributes.getNamedItem("data-header-color").value;

      if (isIntersecting) {
        //Default effects
        const visiblePercentage = Math.round(getVisiblePercentage($section));
        const topDistance = $section.getBoundingClientRect().top;

        $sectionContent.style.opacity = `${calcScrollOpacity(
          visiblePercentage
        )}`;
        $sectionContent.style.zIndex = "20";

        if (topDistance <= 30) {
          $header.style.color = headerColor;
        }

        // Only create the function if it doesn't already exist
        if (!scrollHandlers[sectionName]) {
          scrollHandlers[sectionName] = createScrollHandler(
            $section,
            $sectionContent,
            headerColor
          );
        }

        document.addEventListener("scroll", scrollHandlers[sectionName]);
      } else {
        document.removeEventListener("scroll", scrollHandlers[sectionName]);
        $sectionContent.style.opacity = `0`;
        $sectionContent.style.zIndex = "-999";
      }
    });
  }, options);

  $sections.forEach((section) => {
    observer.observe(section);
  });
</script>
