---
import LayoutHeader from "../LayoutHeader.astro";

interface Props {
  homeSectionName: string;
  headerColor?: string;
  image?: { src: string; alt: string };
  video?: { src: string };
}

const { homeSectionName, image, video, headerColor = "transparent" } = Astro.props;
---

<section
  data-section-name={`section-${homeSectionName}`}
  data-header-color={headerColor}
  class="h-screen relative snap-center"
>
  <LayoutHeader />
  {
    video && (
      <div class="absolute w-full h-full z-10">
        <video
          class="w-full h-full object-cover object-center"
          src={video.src}
          autoplay
          muted
          loop
        />
      </div>
    )
  }

  {
    image && (
      <div class="absolute w-full h-full z-10">
        <img
          src={image?.src}
          alt={image?.alt}
          class="w-full h-full object-cover"
        />
      </div>
    )
  }

  <section
    data-section-content={`section-${homeSectionName}-content`}
    class="absolute z-20 h-full w-full flex flex-col justify-between text-center"
  >
    <slot />
  </section>
</section>

<script>
  const options = {
    root: null,
    rootMargin: "0px",
    threshold: 0.75,
  };

  const $sections = document.querySelectorAll(
    "[data-section-name]"
  ) as NodeListOf<Element>;

  const $sectionsContent = document.querySelectorAll(
    "[data-section-content]"
  ) as NodeListOf<Element>;

  const $homePage = document.querySelector("#home-page");

  function getVisiblePercentage(element) {
    const rect = element.getBoundingClientRect();
    const windowHeight =
      window.innerHeight || document.documentElement.clientHeight;

    const totalHeight = rect.bottom - rect.top;

    const outsideViewportHeight =
      Math.max(0, rect.top < 0 ? Math.abs(rect.top) : 0) +
      Math.max(
        0,
        rect.bottom - windowHeight > 0 ? rect.bottom - windowHeight : 0
      );

    const insideViewportHeight = totalHeight - outsideViewportHeight;

    const visiblePercentage = (insideViewportHeight / totalHeight) * 100;

    return visiblePercentage;
  }

  let observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      const sectionName =
        entry.target.attributes.getNamedItem("data-section-name").value;
      const $sectionContent = [...$sectionsContent].find((el) => {
        return (
          el.attributes.getNamedItem("data-section-content").value ===
          `${sectionName}-content`
        );
      }) as HTMLElement;

      const $header = document.querySelector("#leading-header") as HTMLElement;
      const headerColor =
        entry.target.attributes.getNamedItem("data-header-color").value;

      if (entry.isIntersecting) {
        $sectionContent.classList.remove("hidden");

        const topDistance = entry.target.getBoundingClientRect().top;
        if (topDistance <= 30) {
          $header.style.color = headerColor;
        }

        $homePage.addEventListener("scroll", () => {
          const topDistance = entry.target.getBoundingClientRect().top;

          if (topDistance <= 30) {
            $header.style.color = headerColor;
          }

          const visiblePercentage = Math.round(
            getVisiblePercentage(entry.target)
          );
          $sectionContent.style.bottom = `${topDistance}px`;
          // 75% of visiblePercentage is equal to 0 opacity and 100% is equal to 1 opacity
          // (this increments the velocity of the opacity change)
          $sectionContent.style.opacity = `${(visiblePercentage - 75) / 25}`;
        });
      } else {
        $sectionContent.classList.add("hidden");
        // $homePage.removeEventListener("scroll", () => {});
      }
    });
  }, options);

  $sections.forEach((section) => {
    observer.observe(section);
  });
</script>
